{{define "audioLevelIndicator"}}
<!-- Microphone input level indicator with dropdown -->
<div class="relative w-10 h-10" 
    role="status"
    x-data="{ 
        levels: {},
        selectedSource: null,
        smoothedVolumes: {},
        smoothingFactor: 0.4,
        dropdownOpen: false,
        zeroLevelTime: {},
        eventSource: null,
        reconnectAttempts: 0,
        maxReconnectAttempts: 5,
        reconnectDelay: 1000,
        isNavigating: false,
        retryTimeout: null,
        isPlaying: false,
        playingSource: null, // Track which source is currently playing
        audioPlayer: null, // HLS audio player element
        hlsPlayer: null, // HLS.js instance
        lastDataTime: null,
        _requestedPermission: false,

        isInactive(source) {
            // If we don't have the source in levels at all, consider it inactive
            if (!this.levels[source]) {
                return true;
            }
            // If the source has a non-zero level, it's active
            if (this.levels[source].level > 0) {
                return false;
            }
            // If we haven't started tracking zero time for this source yet
            if (!this.zeroLevelTime[source]) {
                this.zeroLevelTime[source] = Date.now();
                return false;
            }
            // Source is inactive if it has had zero level for more than 5 seconds
            return (Date.now() - this.zeroLevelTime[source]) > 5000;
        },

        cleanupEventSource() {
            if (this.eventSource) {
                this.eventSource.close();
                this.eventSource = null;
            }
            if (this.retryTimeout) {
                clearTimeout(this.retryTimeout);
                this.retryTimeout = null;
            }
        },

        setupEventSource() {
            // Don't setup if we're navigating away or already have a connection
            if (this.isNavigating || this.eventSource) {
                return;
            }
            
            this.cleanupEventSource();
            
            this.eventSource = new EventSource('/api/v1/audio-level');
            
            this.eventSource.onmessage = (event) => {
                // Skip processing if we're navigating away
                if (this.isNavigating) {
                    this.cleanupEventSource();
                    return;
                }
                
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'audio-level') {
                        if (!data.levels) {
                            return;
                        }
                        
                        // Reset reconnect attempts on successful message
                        this.reconnectAttempts = 0;
                        this.reconnectDelay = 1000;
                        
                        // Update levels and track zero level times
                        const oldSources = Object.keys(this.levels);
                        this.levels = data.levels;
                        const newSources = Object.keys(this.levels);
                        
                        // Track when sources start having zero levels
                        Object.entries(this.levels).forEach(([source, data]) => {
                            if (data.level === 0) {
                                if (!this.zeroLevelTime[source]) {
                                    this.zeroLevelTime[source] = Date.now();
                                }
                            } else {
                                delete this.zeroLevelTime[source];
                            }
                        });
                        
                        // Initialize smoothedVolumes for new sources
                        Object.keys(this.levels).forEach(source => {
                            if (!(source in this.smoothedVolumes)) {
                                this.smoothedVolumes[source] = 0;
                            }
                        });
                        
                        // Set first source as selected if none selected
                        if (!this.selectedSource || !(this.selectedSource in this.levels)) {
                            const sources = Object.keys(this.levels);
                            if (sources.length > 0) {
                                this.selectedSource = sources[0];
                            }
                        }
                        
                        // Update smoothed volumes
                        Object.entries(this.levels).forEach(([source, data]) => {
                            const oldVolume = this.smoothedVolumes[source] || 0;
                            this.smoothedVolumes[source] = this.smoothingFactor * data.level + 
                                (1 - this.smoothingFactor) * oldVolume;
                        });
                    }
                } catch (error) {
                    console.error('Error processing SSE data:', error);
                }
            };
            
            this.eventSource.onerror = (error) => {
                console.error('EventSource error:', error);
                this.cleanupEventSource();
                
                // Don't attempt reconnection if we're navigating away
                if (this.isNavigating) {
                    return;
                }
                
                // Implement exponential backoff for reconnection
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.retryTimeout = setTimeout(() => {
                        this.reconnectAttempts++;
                        this.reconnectDelay = Math.min(this.reconnectDelay * 2, 10000); // Cap at 10 seconds
                        console.log('Reconnecting to SSE (attempt ' + this.reconnectAttempts + ')...');
                        this.setupEventSource();
                    }, this.reconnectDelay);
                } else {
                    console.error('Max reconnection attempts reached');
                }
            };
        },

        // Initialize or create the audio player element
        initAudioPlayer() {
            if (this.audioPlayer) {
                return this.audioPlayer;
            }
            
            // Create an audio element for HLS playback
            const audio = document.createElement('audio');
            audio.id = 'hls-audio-player';
            audio.setAttribute('aria-hidden', 'true'); // keep visible to AT
            audio.classList.add('sr-only');            // visually hidden but AT-accessible
            audio.setAttribute('preload', 'none');
            audio.setAttribute('playsinline', '');
            
            // Add event listeners
            audio.addEventListener('playing', () => {
                console.log('HLS audio playback started');
                this.isPlaying = true;
                
                // Update mediaSession for media controls if supported
                this.setupMediaSession(this.playingSource);
            });
            
            audio.addEventListener('pause', () => {
                console.log('HLS audio playback paused');
                this.isPlaying = false;
            });
            
            audio.addEventListener('ended', () => {
                console.log('HLS audio playback ended');
                this.isPlaying = false;
            });
            
            audio.addEventListener('error', (e) => {
                console.error('HLS audio playback error:', e);
                this.isPlaying = false;
            });
            
            // Append to document body
            document.body.appendChild(audio);
            this.audioPlayer = audio;
            
            return audio;
        },
        
        // Start playing HLS stream for the selected source
        startHLSPlayback(sourceId) {
            console.log('Starting HLS audio playback for source: ' + sourceId);
            
            // Get or create audio player
            const player = this.initAudioPlayer();
            
            // Set state
            this.playingSource = sourceId;
            
            // Encode source ID to be URL-safe
            const encodedSourceId = encodeURIComponent(sourceId);
            
            // Set HLS stream URL - use absolute URL to avoid path resolution issues
            const hlsUrl = `${window.location.origin}/api/v1/audio-stream-hls/${encodedSourceId}/playlist.m3u8`;
            console.log('HLS URL: ' + hlsUrl);
            
            // First, notify the server we want to start streaming this source
            // This triggers ffmpeg to start generating the playlist
            this.notifyStreamStart(encodedSourceId)
                .then(() => {
                    // Then attempt to load the playlist with retries
                    return this.loadPlaylistWithRetry(hlsUrl, player, sourceId);
                })
                .catch(error => {
                    console.error('Error accessing audio stream: ' + error.message);
                    alert('Error accessing audio stream: ' + error.message);             
                });
        },
        
        // Notify server that we're starting to stream this source
        notifyStreamStart(encodedSourceId) {
            const startUrl = `${window.location.origin}/api/v1/audio-stream-hls/${encodedSourceId}/start`;
                
            return fetch(startUrl, { method: 'POST' })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to start stream: ' + response.status + ' ' + response.statusText);
                    }
                    console.log('Server notified to start streaming');
                    return response;
                });
        },
        
        // Attempt to load the playlist with retries
        loadPlaylistWithRetry(hlsUrl, player, sourceId, retryCount = 0, maxRetries = 5) {
            const retryDelay = Math.min(1000 * Math.pow(1.5, retryCount), 8000); // Exponential backoff
            
            console.log('Attempting to load playlist, attempt ' + (retryCount + 1) + ' of ' + maxRetries);
            
            return fetch(hlsUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to fetch playlist: ' + response.status + ' ' + response.statusText);
                    }
                    return response.text();
                })
                .then(data => {
                    if (data.length > 0) {
                        console.log('Playlist loaded successfully after ' + (retryCount + 1) + ' attempts');
                        this.startHLSPlaybackWithVerifiedURL(hlsUrl, player, sourceId);
                        return true;
                    } else {
                        throw new Error('Empty playlist received');
                    }
                })
                .catch(error => {
                    console.warn('Playlist load attempt ' + (retryCount + 1) + ' failed: ' + error.message);
                    
                    if (retryCount < maxRetries) {
                        // Show loading status to user
                        if (retryCount === 0) {
                            // First retry, show initial message
                            this.showPlaybackStatus('Starting audio stream, please wait...');
                        } else {
                            // Subsequent retries, show progress
                            this.showPlaybackStatus('Waiting for audio stream... (' + (retryCount + 1) + '/' + maxRetries + ')');
                        }
                        
                        // Retry after delay
                        return new Promise(resolve => {
                            this.retryTimeout = setTimeout(() => {
                                resolve(this.loadPlaylistWithRetry(hlsUrl, player, sourceId, retryCount + 1, maxRetries));
                                this.retryTimeout = null;
                            }, retryDelay);
                        });
                    } else {
                        this.hidePlaybackStatus();
                        throw new Error('Failed to load playlist after multiple attempts. Please try again later.');
                    }
                });
        },
        
        // Show playback status message
        showPlaybackStatus(message) {
            // Create status element if it doesn't exist
            let statusEl = document.getElementById('hls-playback-status');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'hls-playback-status';
                statusEl.className = 'fixed bottom-4 right-4 bg-primary text-primary-content p-2 rounded shadow-lg z-50';
                statusEl.setAttribute('role', 'status');
                statusEl.setAttribute('aria-live', 'polite');
                document.body.appendChild(statusEl);
            }
            
            statusEl.textContent = message;
            statusEl.style.display = 'block';
        },
        
        // Hide playback status
        hidePlaybackStatus() {
            const statusEl = document.getElementById('hls-playback-status');
            if (statusEl) {
                statusEl.style.display = 'none';
            }
        },
        
        // Start HLS playback after verifying the playlist URL works
        startHLSPlaybackWithVerifiedURL(hlsUrl, player, sourceId) {
            // Check if HLS.js is supported and needed
            if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                console.log('Using HLS.js for playback');
                
                // Clean up existing HLS.js instance if it exists
                if (this.hlsPlayer) {
                    this.hlsPlayer.destroy();
                }
                
                // Create new HLS.js instance
                const hls = new Hls({
                    debug: false, // Disable debug logging (was true)
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 30
                });
                
                // Bind HLS events
                hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                    console.log('HLS.js media attached');
                    hls.loadSource(hlsUrl);
                });
                
                hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
                    console.log('HLS.js manifest parsed, found ' + data.levels.length + ' quality levels');
                    player.play().catch(err => {
                        console.error('Error starting HLS playback:', err);
                        if (err.name === 'NotAllowedError') {
                            console.warn('Autoplay blocked. User interaction required to play audio.');
                        }
                    });
                });
                
                hls.on(Hls.Events.ERROR, (event, data) => {
                    console.error('HLS.js error:', data.type, data.details, data.fatal);
                    if (data.fatal) {
                        console.error('Fatal HLS.js error:', data.type, data.details);
                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                // Try to recover network error
                                console.log('Trying to recover from HLS network error...');
                                hls.startLoad();
                                break;
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log('Trying to recover from HLS media error...');
                                hls.recoverMediaError();
                                break;
                            default:
                                // Cannot recover
                                hls.destroy();
                                break;
                        }
                    }
                });
                
                // Attach to media element
                hls.attachMedia(player);
                this.hlsPlayer = hls;
                
            } else if (player.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS support (Safari, iOS)
                console.log('Using native HLS support');
                player.src = hlsUrl;
                player.play().catch(err => {
                    console.error('Error starting HLS playback:', err);
                    if (err.name === 'NotAllowedError') {
                        console.warn('Autoplay blocked. User interaction required to play audio.');
                    }
                });
            } else {
                console.error('HLS playback not supported on this browser');
                alert('Your browser does not support HLS audio streaming. Please try a modern browser like Chrome, Firefox, or Safari.');
            }
            
            // Setup media session for media controls
            this.setupMediaSession(sourceId);
        },
        
        // Stop HLS playback
        stopHLSPlayback() {
            console.log('Stopping HLS audio playback');
            
            // Hide any playback status messages
            this.hidePlaybackStatus();
            
            if (this.audioPlayer) {
                this.audioPlayer.pause();
                this.audioPlayer.src = '';
            }
            
            // Clean up HLS.js if it exists
            if (this.hlsPlayer) {
                this.hlsPlayer.destroy();
                this.hlsPlayer = null;
            }
            
            // Notify server that we've stopped playback
            if (this.playingSource) {
                const encodedSourceId = encodeURIComponent(this.playingSource);
                const stopUrl = `${window.location.origin}/api/v1/audio-stream-hls/${encodedSourceId}/stop`;
                
                fetch(stopUrl, { method: 'POST' })
                    .then(() => console.log('Server notified of playback stop'))
                    .catch(err => console.error('Failed to notify server of playback stop:', err));
            }
            
            // Reset state
            this.isPlaying = false;
            this.playingSource = null;
            
            // Update mediaSession state if available
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'paused';
            }
        },
        
        // Setup media session API for media controls
        setupMediaSession(source) {
            if ('mediaSession' in navigator) {
                const sourceName = source ? this.getSourceDisplayName(source) : '';
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: sourceName ? 'Bird Audio Stream - ' + sourceName : 'Bird Audio Stream',
                    artist: 'BirdNet-Go',
                    album: 'Live Stream',
                    // Optional artwork - use favicon as default
                    artwork: [
                        { src: '/assets/favicon.ico', sizes: '32x32', type: 'image/x-icon' },
                    ]
                });
                
                navigator.mediaSession.setActionHandler('play', () => {
                    if (this.audioPlayer) {
                        this.audioPlayer.play();
                    }
                });
                
                navigator.mediaSession.setActionHandler('pause', () => {
                    if (this.audioPlayer) {
                        this.audioPlayer.pause();
                    }
                });
                
                // Update playback state
                navigator.mediaSession.playbackState = 'playing';
            }
        },
        
        // Toggle playback for currently selected source
        togglePlayback() {
            if (!this.selectedSource) {
                console.error('No audio source selected');
                return;
            }
            
            if (this.isPlaying) {
                this.stopHLSPlayback();
            } else {
                this.startHLSPlayback(this.selectedSource);
            }
        },
        
        // Toggle playback for a specific source
        toggleSourcePlayback(source) {
            // If we're already playing this source, stop it
            if (this.isPlaying && this.playingSource === source) {
                this.stopHLSPlayback();
                return;
            }
            
            // If we're playing a different source, stop it first
            if (this.isPlaying) {
                this.stopHLSPlayback();
            }
            
            // Start playing the new source
            this.startHLSPlayback(source);
        },

        // Initialize component
        init() {
            // Setup initial connection for audio levels
            this.setupEventSource();
            
            // Listen for navigation events
            document.addEventListener('htmx:beforeRequest', () => {
                this.isNavigating = true;
                this.cleanupEventSource();
                
                // Stop audio playback if navigating
                if (this.isPlaying) {
                    this.stopHLSPlayback();
                }
            });
            
            document.addEventListener('htmx:afterRequest', () => {
                this.isNavigating = false;
                // Only setup new connection if we're still on a page that needs it
                if (document.body.contains(this.$el)) {
                    this.setupEventSource();
                }
            });

            // Listen for page visibility changes
            const visibilityHandler = () => {
                if (document.hidden) {
                    // When tab goes to background
                    this.cleanupEventSource(); // Close the audio level EventSource when hidden
                    
                    // We don't need to pause HLS audio - it can keep playing in background
                    console.log('Tab in background: continuing audio playback');
                    
                } else if (!this.isNavigating) {
                    // When tab becomes visible again
                    this.setupEventSource();
                    
                    // If we were playing and the player has stopped, restart
                    if (this.playingSource && this.audioPlayer && 
                        (this.audioPlayer.paused || this.audioPlayer.ended)) {
                        console.log('Tab visible again: resuming audio playback');
                        this.startHLSPlayback(this.playingSource);
                    }
                }
            };
            
            document.addEventListener('visibilitychange', visibilityHandler);
            
            // Clean up on component destroy
            this.$cleanup = () => {
                this.cleanupEventSource();
                document.removeEventListener('visibilitychange', visibilityHandler);
                document.removeEventListener('htmx:beforeRequest', this.cleanupEventSource);
                document.removeEventListener('htmx:afterRequest', this.setupEventSource);
                
                // Clean up audio player
                if (this.audioPlayer) {
                    this.audioPlayer.pause();
                    this.audioPlayer.src = '';
                    this.audioPlayer.remove();
                    this.audioPlayer = null;
                }
                
                // Clean up HLS.js if it exists
                if (this.hlsPlayer) {
                    this.hlsPlayer.destroy();
                    this.hlsPlayer = null;
                }
            };
        },
        
        // Get current audio level
        getCurrentLevel() {
            const level = this.selectedSource && this.levels[this.selectedSource] ? 
                this.levels[this.selectedSource].level : 0;
            return level;
        },
        
        // Check if audio is clipping
        isClipping() {
            const clipping = this.selectedSource && this.levels[this.selectedSource] ? 
                this.levels[this.selectedSource].clipping : false;
            return clipping;
        },
        
        // Get smoothed volume for visualization
        getSmoothedVolume() {
            const volume = this.selectedSource ? this.smoothedVolumes[this.selectedSource] || 0 : 0;
            return volume;
        },
        
        // Get display name for a source
        getSourceDisplayName(source) {
            const name = this.levels[source]?.name || source;
            return name;
        }
    }" 
    @click.away="dropdownOpen = false">
    
    <!-- Audio level indicator circle -->
    <button @click="dropdownOpen = !dropdownOpen" 
            class="w-full h-full relative focus:outline-none group" 
            :aria-expanded="dropdownOpen"
            aria-haspopup="true"
            :aria-label="'Audio level for ' + (selectedSource ? getSourceDisplayName(selectedSource) : 'No source')"
            tabindex="0">
        <svg class="w-full h-full" viewBox="0 0 36 36" aria-hidden="true">
            <!-- Background circle path -->
            <path d="M18 2.0845
                        a 15.9155 15.9155 0 0 1 0 31.831
                        a 15.9155 15.9155 0 0 1 0 -31.831" 
                    fill="none" 
                    stroke="#E5E7EB" 
                    stroke-width="3" 
                    stroke-dasharray="100, 100"></path>
            <!-- Foreground circle path -->
            <path d="M18 33.9155
                        a 15.9155 15.9155 0 0 1 0 -31.831
                        a 15.9155 15.9155 0 0 1 0 31.831" 
                    fill="none" 
                    :stroke="isClipping() ? '#EF4444' : '#10B981'" 
                    stroke-width="3" 
                    :stroke-dasharray="getSmoothedVolume() + ', 100'"
                    stroke-linecap="round">
            </path>
        </svg>
        <div class="absolute inset-0 flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd"></path>
            </svg>
        </div>
        <!-- Live region to announce volume changes -->
        <div class="sr-only" aria-live="polite" x-text="'Current audio level: ' + Math.round(getSmoothedVolume()) + ' percent' + (isClipping() ? ', clipping detected' : '')"></div>
    </button>

    {{if or (not $.Security.Enabled) $.Security.AccessAllowed}}
    <!-- Tooltip for selected source -->
    <div x-show="selectedSource && !dropdownOpen"
         x-transition:enter="transition ease-out duration-100"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-75"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         class="invisible group-hover:visible absolute left-1/2 transform -translate-x-1/2 -translate-y-full mt-2 px-2 py-1 bg-gray-900 text-gray-50 text-sm rounded whitespace-nowrap z-50"
         style="top: -5px;"
         aria-hidden="true">
        <span x-text="selectedSource ? getSourceDisplayName(selectedSource) : 'No source selected'"></span>
    </div>
    
    <!-- Dropdown menu, shown only for authenticated users -->
    <div x-show="dropdownOpen"
         role="dialog"
         aria-modal="true"
         :aria-label="'Audio Source Selection'"
         class="absolute p-1 right-0 mt-2 w-auto min-w-[12rem] max-w-[90vw] overflow-hidden rounded-md shadow-lg bg-base-100 ring-1 ring-black ring-opacity-5 z-50"
         x-transition:enter="transition ease-out duration-100"
         x-transition:enter-start="opacity-0 scale-95"
         x-transition:enter-end="opacity-100 scale-100"
         x-transition:leave="transition ease-in duration-75"
         x-transition:leave-start="opacity-100 scale-100"
         x-transition:leave-end="opacity-0 scale-95"
         @keydown.escape.window="dropdownOpen = false"
         @keydown.tab="$event.shiftKey || $el.querySelector('.last-focusable').focus()"
         @keydown.shift.tab="$el.querySelector('.first-focusable').focus()">
        <div class="py-1" role="menu" aria-orientation="vertical">
            <template x-if="Object.keys(levels).length === 0">
                <div class="px-4 py-2 text-sm text-base-content/60" role="menuitem">No audio sources available</div>
            </template>
            <template x-for="(data, source) in levels" :key="source">
                <div class="flex flex-row items-center w-full p-2 text-sm hover:bg-base-200 rounded-md"
                     :class="{
                         'bg-base-200': selectedSource === source,
                         'text-base-content/50': isInactive(source),
                         'text-base-content': !isInactive(source)
                     }"
                     role="menuitem"
                     :id="'source-item-' + source">
                    <!-- Source name area (clickable to select) -->
                    <button @click="selectedSource = source; dropdownOpen = false" 
                            class="flex-1 text-left flex items-center justify-between"
                            role="menuitemradio"
                            :aria-checked="selectedSource === source"
                            :tabindex="source === Object.keys(levels)[0] ? 0 : -1"
                            :class="{ 'first-focusable': source === Object.keys(levels)[0] }"
                            @keydown.right="$event.target.nextElementSibling?.focus()">
                        <span class="flex-1 whitespace-nowrap" x-text="getSourceDisplayName(source)"></span>
                        <span x-show="isInactive(source)" class="text-xs text-base-content/50 shrink-0 ml-2" aria-hidden="true">(silent)</span>
                        <!-- Accessible label that includes silence status -->
                        <span class="sr-only" x-text="isInactive(source) ? getSourceDisplayName(source) + ' (currently silent)' : getSourceDisplayName(source)"></span>
                    </button>
                    
                    <!-- Play/Stop controls directly in same row -->
                    <button 
                            @click="toggleSourcePlayback(source); dropdownOpen = false" 
                            class="btn btn-xs btn-circle btn-ghost ml-2"
                            :class="playingSource === source ? 'text-error' : 'text-success'"
                            :aria-label="playingSource === source ? 'Stop audio playback' : 'Start audio playback'"
                            :tabindex="0"
                            @keydown.left="$event.target.previousElementSibling?.focus()">
                        <template x-if="playingSource !== source">
                            <!-- Play icon (>) -->
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                            </svg>
                        </template>
                        <template x-if="playingSource === source">
                            <!-- Stop icon (#) -->
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd" />
                            </svg>
                        </template>
                    </button>
                </div>
            </template>
        </div>
    </div>
    
    {{end}}

    <!-- Live region for audio playback status -->
    <div aria-live="polite" class="sr-only">
        <span x-show="isPlaying" x-text="'Now playing audio from ' + (selectedSource ? getSourceDisplayName(selectedSource) : 'unknown source')"></span>
        <span x-show="!isPlaying && selectedSource" x-text="'Audio playback stopped'"></span>
    </div>

</div>

<!-- Add this script to the bottom for better keyboard navigation -->
<script>
document.addEventListener('alpine:init', () => {
    // A11y: Enhance keyboard interaction for dropdown
    window.addEventListener('keydown', (e) => {
        // Close dropdown on escape
        if (e.key === 'Escape' && Alpine.$data(document.querySelector('[x-data*="dropdownOpen"]')).dropdownOpen) {
            Alpine.$data(document.querySelector('[x-data*="dropdownOpen"]')).dropdownOpen = false;
        }
    });
});
</script>
{{end}} 