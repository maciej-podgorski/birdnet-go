{{define "audioLevelIndicator"}}
<!-- Microphone input level indicator with dropdown -->
<div class="relative w-10 h-10" 
    role="status"
    x-data="{ 
        levels: {},
        selectedSource: null,
        smoothedVolumes: {},
        smoothingFactor: 0.4,
        dropdownOpen: false,
        zeroLevelTime: {},
        eventSource: null,
        reconnectAttempts: 0,
        maxReconnectAttempts: 5,
        reconnectDelay: 1000,
        isNavigating: false,
        retryTimeout: null,
        isPlaying: false,
        playingSource: null, // Track which source is currently playing
        audioElement: null, // HTML5 audio element
        hlsPlayer: null, // HLS.js instance
        lastDataTime: null,
        _requestedPermission: false,
        errorCount: 0,
        lastErrorTime: null,
        inErrorCooldown: false,
        nonFatalErrorCount: 0,
        lastNonFatalErrorTime: null,
        // Heartbeat tracking
        heartbeatInterval: null,
        heartbeatFrequency: 20000, // Send heartbeat every 20 seconds
        heartbeatErrorCount: 0,
        playbackStabilizing: false,

        isInactive(source) {
            // If we don't have the source in levels at all, consider it inactive
            if (!this.levels[source]) {
                return true;
            }
            // If the source has a non-zero level, it's active
            if (this.levels[source].level > 0) {
                return false;
            }
            // If we haven't started tracking zero time for this source yet
            if (!this.zeroLevelTime[source]) {
                this.zeroLevelTime[source] = Date.now();
                return false;
            }
            // Source is inactive if it has had zero level for more than 5 seconds
            return (Date.now() - this.zeroLevelTime[source]) > 5000;
        },

        cleanupEventSource() {
            if (this.eventSource) {
                this.eventSource.close();
                this.eventSource = null;
            }
            if (this.retryTimeout) {
                clearTimeout(this.retryTimeout);
                this.retryTimeout = null;
            }
        },

        setupEventSource() {
            // Don't setup if we're navigating away or already have a connection
            if (this.isNavigating || this.eventSource) {
                return;
            }
            
            this.cleanupEventSource();
            
            try {
                this.eventSource = new EventSource('/api/v1/audio-level');
                
                this.eventSource.onmessage = (event) => {
                    // Skip processing if we're navigating away
                    if (this.isNavigating) {
                        this.cleanupEventSource();
                        return;
                    }
                    
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'audio-level') {
                            if (!data.levels) {
                                return;
                            }
                            
                            // Reset reconnect attempts on successful message
                            this.reconnectAttempts = 0;
                            this.reconnectDelay = 1000;
                            
                            // Update levels and track zero level times
                            const oldSources = Object.keys(this.levels);
                            this.levels = data.levels;
                            const newSources = Object.keys(this.levels);
                            
                            // Track when sources start having zero levels
                            Object.entries(this.levels).forEach(([source, data]) => {
                                if (data.level === 0) {
                                    if (!this.zeroLevelTime[source]) {
                                        this.zeroLevelTime[source] = Date.now();
                                    }
                                } else {
                                    delete this.zeroLevelTime[source];
                                }
                            });
                            
                            // Initialize smoothedVolumes for new sources
                            Object.keys(this.levels).forEach(source => {
                                if (!(source in this.smoothedVolumes)) {
                                    this.smoothedVolumes[source] = 0;
                                }
                            });
                            
                            // Set first source as selected if none selected
                            if (!this.selectedSource || !(this.selectedSource in this.levels)) {
                                const sources = Object.keys(this.levels);
                                if (sources.length > 0) {
                                    this.selectedSource = sources[0];
                                }
                            }
                            
                            // Update smoothed volumes
                            Object.entries(this.levels).forEach(([source, data]) => {
                                const oldVolume = this.smoothedVolumes[source] || 0;
                                this.smoothedVolumes[source] = this.smoothingFactor * data.level + 
                                    (1 - this.smoothingFactor) * oldVolume;
                            });
                        }
                    } catch (error) {
                        console.error('Error processing SSE data:', error);
                    }
                };
                
                this.eventSource.onerror = (error) => {
                    console.error('EventSource error:', error);
                    this.cleanupEventSource();
                    
                    // Don't stop audio playback when SSE connection fails
                    // This was causing a stop message to be sent to the server unnecessarily
                    if (this.isPlaying) {
                        console.warn('EventSource error, but continuing audio playback');
                        // Only show a transient warning
                        this.showPlaybackStatus('Audio level updates paused, playback continues');
                        setTimeout(() => this.hidePlaybackStatus(), 3000);
                    }
                    
                    // Don't attempt reconnection if we're navigating away
                    if (this.isNavigating) {
                        return;
                    }
                    
                    // Implement more generous reconnection with exponential backoff
                    // Increase max retries since EventSource errors shouldn't stop playback
                    const maxRetries = 10; // Increased from 5
                    if (this.reconnectAttempts < maxRetries) {
                        this.retryTimeout = setTimeout(() => {
                            this.reconnectAttempts++;
                            // Cap backoff at 15 seconds (increased from 10)
                            this.reconnectDelay = Math.min(this.reconnectDelay * 1.5, 15000);
                            console.log('Reconnecting to SSE (attempt ' + this.reconnectAttempts + ')...');
                            this.setupEventSource();
                        }, this.reconnectDelay);
                    } else {
                        console.error('Max EventSource reconnection attempts reached');
                        // Even after max retries, don't stop playback
                        // Just let user know about the situation
                        this.showPlaybackStatus('Unable to update audio levels, stream continues');
                        setTimeout(() => this.hidePlaybackStatus(), 5000);
                    }
                };
            } catch (e) {
                console.error('Error setting up EventSource:', e);
                // If we can't even set up the EventSource, try again after a delay
                setTimeout(() => this.setupEventSource(), 5000);
            }
        },
        
        // Send heartbeat to server to maintain session
        sendHeartbeat() {
            // Only send heartbeat if we're playing something
            if (!this.isPlaying || !this.playingSource) {
                return;
            }
            
            const heartbeatUrl = `${window.location.origin}/api/v1/audio-stream-hls/heartbeat`;
            const heartbeatData = {
                source_id: this.playingSource
            };
            
            fetch(heartbeatUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(heartbeatData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Heartbeat failed: ' + response.status);
                }
                // Reset error count on success
                this.heartbeatErrorCount = 0;
                
                // Just mark it as successful, don't parse the JSON
                return;
            })
            .catch(error => {
                console.warn('Failed to send heartbeat:', error);
                this.heartbeatErrorCount++;
                
                // If too many consecutive heartbeat failures, assume connection lost
                if (this.heartbeatErrorCount > 3) {
                    console.error('Multiple heartbeat failures - connection may be lost');
                    
                    // Don't stop playback though - the HLS player will detect media errors
                    // and we don't want to interrupt playback unnecessarily
                }
            });
        },
        
        // Start heartbeat interval
        startHeartbeat() {
            this.stopHeartbeat(); // Clear any existing interval
            
            // Start new heartbeat interval
            this.heartbeatInterval = setInterval(() => {
                this.sendHeartbeat();
            }, this.heartbeatFrequency);
            
            // Send initial heartbeat immediately
            this.sendHeartbeat();
        },
        
        // Stop heartbeat interval
        stopHeartbeat() {
            if (this.heartbeatInterval) {
                clearInterval(this.heartbeatInterval);
                this.heartbeatInterval = null;
            }
            this.heartbeatErrorCount = 0;
            
            // Don't send disconnect notification during playback stabilization
            if (this.playbackStabilizing) {
                console.log('Suppressing disconnect notification during playback stabilization');
                return;
            }
            
            // Send a final disconnect notification if we were playing something
            if (this.playingSource) {
                const heartbeatUrl = `${window.location.origin}/api/v1/audio-stream-hls/heartbeat?disconnect=true`;
                const heartbeatData = {
                    source_id: this.playingSource
                };
                
                // Use a simple fetch with timeout to avoid hanging during page navigation
                fetch(heartbeatUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(heartbeatData),
                    // Add timeout to prevent hanging during navigation
                    signal: AbortSignal.timeout(3000)
                })
                .then(response => {
                    // Just verify we got a response, no need to parse it
                    if (response.ok) {
                        console.log('Successfully sent disconnect notification');
                    }
                })
                .catch(error => {
                    // Just log the error, don't attempt to retry as we're disconnecting anyway
                    console.warn('Failed to send disconnect notification:', error);
                });
            }
        },
        
        // Get or create audio element
        getAudioElement() {
            if (!this.audioElement) {
                // Create a HTML5 audio element for HLS playback
                const audio = document.createElement('audio');
                audio.id = 'hls-audio-player';
                audio.setAttribute('aria-hidden', 'true'); // keep visible to AT
                audio.classList.add('sr-only');            // visually hidden but AT-accessible
                audio.setAttribute('preload', 'auto');
                audio.setAttribute('playsinline', '');
                
                // Add event listeners
                audio.addEventListener('playing', () => {
                    console.log('Audio playback started');
                    this.isPlaying = true;
                    this.hidePlaybackStatus();
                    this.setupMediaSession(this.playingSource);
                    
                    // Reset error counts when playback starts successfully
                    this.errorCount = 0;
                    this.lastErrorTime = null;
                });
                
                audio.addEventListener('pause', () => {
                    console.log('Audio playback paused');
                    this.isPlaying = false;
                });
                
                audio.addEventListener('ended', () => {
                    console.log('Audio playback ended');
                    this.isPlaying = false;
                });
                
                // Improved error handling to prevent loops
                audio.addEventListener('error', (e) => {
                    // Get current timestamp
                    const now = Date.now();
                    
                    // Initialize error tracking if needed
                    if (!this.errorCount) this.errorCount = 0;
                    if (!this.lastErrorTime) this.lastErrorTime = 0;
                    
                    // Check if this is a rapid succession error (within 2 seconds of the last one)
                    const isRapidError = (now - this.lastErrorTime) < 2000;
                    
                    // If we're getting rapid errors, increase the count
                    if (isRapidError) {
                        this.errorCount++;
                        console.warn(`Rapid error #${this.errorCount}: Audio playback error`);
                        
                        // If we've had too many rapid errors, assume server is down
                        if (this.errorCount > 2) {
                            console.error('Multiple rapid errors detected - server may be unreachable');
                            this.showPlaybackStatus('Server appears to be offline. Playback stopped.');
                            this.stopPlayback(true); // Pass true to indicate we're in error recovery
                            return; // Exit to prevent loop
                        }
                    } else {
                        // Not a rapid error, reset counter but track the error
                        this.errorCount = 1;
                        console.error('Audio playback error:', e);
                    }
                    
                    // Update last error time
                    this.lastErrorTime = now;
                    
                    // Set error message - only if not in a rapid succession
                    if (!isRapidError) {
                        this.showPlaybackStatus('Playback error: ' + (e.target.error ? e.target.error.message : 'Connection lost'));
                    }
                    
                    // Always mark playback as stopped
                    this.isPlaying = false;
                    
                    // Only call stopPlayback if not in a rapid error sequence
                    if (!isRapidError) {
                        this.stopPlayback();
                    }
                });
                
                // Append to document body
                document.body.appendChild(audio);
                this.audioElement = audio;
            }
            
            return this.audioElement;
        },
        
        // Start playing HLS stream for the selected source
        startPlayback(sourceId) {
            console.log('Starting audio playback for source: ' + sourceId);
            
            // If we're already starting playback for this source and still stabilizing, do nothing
            if (this.playbackStabilizing && this.playingSource === sourceId) {
                console.log('Ignoring duplicate start request during stabilization');
                return;
            }
            
            // Add stabilization flag to prevent unwanted disconnect during startup
            this.playbackStabilizing = true;
            
            // Stop any existing playback, but skip server notification if we're restarting the same source
            const skipNotification = (this.playingSource === sourceId);
            this.stopPlayback(false, skipNotification);
            
            // Set state
            this.playingSource = sourceId;
            this.showPlaybackStatus('Starting audio stream...');
            
            // Encode source ID to be URL-safe
            const encodedSourceId = encodeURIComponent(sourceId);
            
            // Notify server we want to start streaming this source
            this.notifyStreamStart(encodedSourceId)
                .then(() => {
                    // After notifying server, set up HLS stream
                    const hlsUrl = `${window.location.origin}/api/v1/audio-stream-hls/${encodedSourceId}/playlist.m3u8`;
                    this.setupHLSStream(hlsUrl, sourceId);
                    
                    // Start heartbeat to let server know we're still connected
                    this.startHeartbeat();
                    
                    // Send an immediate heartbeat to ensure connection is registered
                    setTimeout(() => this.sendHeartbeat(), 500);
                    
                    // Clear stabilization flag after a delay
                    setTimeout(() => {
                        this.playbackStabilizing = false;
                        console.log('Playback stabilized');
                    }, 5000);
                })
                .catch(error => {
                    this.playbackStabilizing = false;
                    console.error('Error accessing audio stream: ' + error.message);
                    this.showPlaybackStatus('Error starting stream: ' + error.message);
                    setTimeout(() => this.hidePlaybackStatus(), 3000);
                });
        },
        
        // Notify server that we're starting to stream this source
        notifyStreamStart(encodedSourceId) {
            const startUrl = `${window.location.origin}/api/v1/audio-stream-hls/${encodedSourceId}/start`;
                
            return fetch(startUrl, { method: 'POST' })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to start stream: ' + response.status + ' ' + response.statusText);
                    }
                    console.log('Server notified to start streaming');
                    return response;
                });
        },

        // Set up HLS streaming
        setupHLSStream(hlsUrl, sourceId) {
            const audio = this.getAudioElement();
            
            // First check if HLS.js is supported
            if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                console.log('Using HLS.js for playback');
                
                // Clean up existing HLS.js instance if it exists
                if (this.hlsPlayer) {
                    this.hlsPlayer.destroy();
                    this.hlsPlayer = null;
                }
                
                // Create new HLS.js instance
                const hls = new Hls({
                    debug: false, // Set to true for debugging
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 30,
                    // More resilient config with higher retry counts for transient issues
                    manifestLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 8000, // Increased from 5000 
                            maxLoadTimeMs: 15000,       // Increased from 10000
                            timeoutRetry: {
                                maxNumRetry: 3,         // Increased from 1
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 3,         // Increased from 1
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 8000
                            }
                        }
                    },
                    playlistLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 8000, // Increased from 5000
                            maxLoadTimeMs: 15000,       // Increased from 10000
                            timeoutRetry: {
                                maxNumRetry: 3,         // Increased from 1
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 3,         // Increased from 1
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 8000
                            }
                        }
                    },
                    fragLoadPolicy: {
                        default: {
                            maxTimeToFirstByteMs: 8000, // Increased from 5000
                            maxLoadTimeMs: 30000,       // Increased from 20000
                            timeoutRetry: {
                                maxNumRetry: 3,         // Increased from 1
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 0
                            },
                            errorRetry: {
                                maxNumRetry: 5,         // Increased from 1
                                retryDelayMs: 1000,
                                maxRetryDelayMs: 8000
                            }
                        }
                    }
                });
                
                // Timeout for initial loading - more aggressive detection of server issues
                const initialLoadTimeout = setTimeout(() => {
                    if (this.hlsPlayer && !this.isPlaying) {
                        console.error('Timeout waiting for initial playback');
                        this.showPlaybackStatus('Server not responding - playback stopped');
                        this.stopPlayback(true); // Use error recovery mode
                    }
                }, 8000); // 8 seconds max to get initial playback
                
                // Set up error handling
                hls.on(Hls.Events.ERROR, (event, data) => {
                    if (data.fatal) {
                        console.error('Fatal HLS.js error:', data.type, data.details);
                        
                        // Clear initial load timeout as we've received a definitive error
                        clearTimeout(initialLoadTimeout);
                        
                        switch(data.type) {
                            case Hls.ErrorTypes.NETWORK_ERROR:
                                console.log('Attempting to recover from network error:', data.details);
                                // For most network errors, try to recover by reloading
                                if (data.details === Hls.ErrorDetails.MANIFEST_LOAD_ERROR || 
                                    data.details === Hls.ErrorDetails.MANIFEST_LOAD_TIMEOUT) {
                                    
                                    // Manifest errors might be fatal, but let's try once more
                                    console.warn('Manifest load issue - trying one more time');
                                    this.showPlaybackStatus('Network issue - retrying connection...');
                                    
                                    // Allow a bit of time for network to recover
                                    setTimeout(() => {
                                        if (this.hlsPlayer) {
                                            hls.loadSource(hlsUrl);
                                            hls.startLoad();
                                        }
                                    }, 2000);
                                } else if (data.details === Hls.ErrorDetails.FRAG_LOAD_ERROR || 
                                           data.details === Hls.ErrorDetails.FRAG_LOAD_TIMEOUT) {
                                    
                                    // Fragment load errors are often transient
                                    console.warn('Fragment load issue - trying to continue');
                                    this.showPlaybackStatus('Network glitch - reconnecting...');
                                    hls.recoverMediaError();
                                    
                                    // Attempt to start loading again after a short delay
                                    setTimeout(() => {
                                        if (this.hlsPlayer) {
                                            hls.startLoad();
                                        }
                                    }, 1000);
                                } else {
                                    // For other network errors, try a general recovery
                                    hls.startLoad();
                                }
                                break;
                                
                            case Hls.ErrorTypes.MEDIA_ERROR:
                                console.log('Attempting to recover from media error');
                                this.showPlaybackStatus('Media issue - recovering...');
                                hls.recoverMediaError();
                                break;
                                
                            default:
                                // Only treat as unrecoverable if it's truly fatal
                                console.error('Unrecoverable HLS error:', data.details);
                                this.showPlaybackStatus('Playback error: ' + data.details);
                                
                                // Try one final recovery attempt
                                try {
                                    hls.destroy();
                                    this.hlsPlayer = null;
                                    
                                    // Wait a moment then try to restart the stream
                                    setTimeout(() => {
                                        if (this.playingSource) {
                                            console.log('Final recovery attempt for source:', this.playingSource);
                                            this.setupHLSStream(hlsUrl, this.playingSource);
                                        }
                                    }, 3000);
                                } catch (e) {
                                    console.error('Recovery failed:', e);
                                    this.stopPlayback(true); // Only stop as last resort
                                }
                                break;
                        }
                    } else {
                        // Non-fatal errors can be logged for debugging
                        console.warn('Non-fatal HLS error:', data.type, data.details);
                        
                        // If we get multiple non-fatal errors in quick succession, it might indicate a problem
                        const now = Date.now();
                        if (!this.nonFatalErrorCount) this.nonFatalErrorCount = 0;
                        if (!this.lastNonFatalErrorTime) this.lastNonFatalErrorTime = 0;
                        
                        // Check if this is a rapid succession error (within 3 seconds of the last one)
                        const isRapidNonFatalError = (now - this.lastNonFatalErrorTime) < 3000;
                        
                        if (isRapidNonFatalError) {
                            this.nonFatalErrorCount++;
                            
                            // Significantly increased threshold - only stop after many rapid errors
                            // as non-fatal buffer stall errors can happen during normal playback
                            if (this.nonFatalErrorCount > 15) {
                                console.error('Multiple rapid non-fatal errors detected - stopping playback');
                                this.showPlaybackStatus('Persistent streaming issues - stopping playback');
                                this.stopPlayback(true); // Use error recovery mode
                            } else if (this.nonFatalErrorCount > 5 && this.nonFatalErrorCount <= 15) {
                                // For moderate number of errors, just show a warning but continue
                                console.warn(`Multiple non-fatal errors (${this.nonFatalErrorCount}) - stream may be unstable`);
                                this.showPlaybackStatus('Stream connection unstable - trying to recover');
                                setTimeout(() => this.hidePlaybackStatus(), 3000);
                            }
                        } else {
                            // Reset counter for non-rapid errors
                            this.nonFatalErrorCount = 1;
                        }
                        
                        this.lastNonFatalErrorTime = now;
                    }
                });
                
                // Media parsing and ready events
                hls.on(Hls.Events.MANIFEST_PARSED, () => {
                    console.log('HLS.js manifest parsed');
                    // Clear initial timeout as manifest is loaded
                    clearTimeout(initialLoadTimeout);
                    
                    // Start playing when manifest is parsed
                    audio.play().catch(err => {
                        console.error('Error starting playback:', err);
                        if (err.name === 'NotAllowedError') {
                            this.showPlaybackStatus('Click to play (autoplay blocked)');
                        }
                    });
                });
                
                // Successfully buffered fragment - update user
                hls.on(Hls.Events.FRAG_BUFFERED, () => {
                    console.log('HLS fragment buffered');
                    // Clear initial timeout as we've buffered content
                    clearTimeout(initialLoadTimeout);
                    
                    if (!this.isPlaying && !audio.paused) {
                        this.isPlaying = true;
                        this.hidePlaybackStatus();
                        
                        // Reset error counters on successful playback
                        this.nonFatalErrorCount = 0;
                        this.errorCount = 0;
                        this.lastErrorTime = 0;
                        this.lastNonFatalErrorTime = 0;
                    }
                });
                
                // Attach to media element and load source
                hls.attachMedia(audio);
                
                // Store HLS instance
                this.hlsPlayer = hls;
                
                // Once media is attached, load the source
                hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                    console.log('HLS.js media attached');
                    hls.loadSource(hlsUrl);
                });
                
            } else if (audio.canPlayType('application/vnd.apple.mpegurl')) {
                // Native HLS support (Safari, iOS)
                console.log('Using native HLS support');
                audio.src = hlsUrl;
                audio.play().catch(err => {
                    console.error('Error starting playback:', err);
                    if (err.name === 'NotAllowedError') {
                        this.showPlaybackStatus('Click to play (autoplay blocked)');
                    }
                });
            } else {
                this.showPlaybackStatus('HLS playback not supported in this browser');
                console.error('HLS playback not supported');
            }
        },
        
        // Show playback status message
        showPlaybackStatus(message) {
            // Create status element if it doesn't exist
            let statusEl = document.getElementById('hls-playback-status');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'hls-playback-status';
                statusEl.className = 'fixed bottom-4 right-4 bg-primary text-primary-content p-2 rounded shadow-lg z-50';
                statusEl.setAttribute('role', 'status');
                statusEl.setAttribute('aria-live', 'polite');
                document.body.appendChild(statusEl);
            }
            
            statusEl.textContent = message;
            statusEl.style.display = 'block';
        },
        
        // Hide playback status
        hidePlaybackStatus() {
            const statusEl = document.getElementById('hls-playback-status');
            if (statusEl) {
                statusEl.style.display = 'none';
            }
        },
        
        // Stop audio playback
        stopPlayback(isErrorRecovery = false, skipServerNotification = false) {
            // Don't stop playback if we're in stabilization phase and this isn't error recovery
            if (this.playbackStabilizing && !isErrorRecovery) {
                console.log('Ignoring stop request during playback stabilization');
                return;
            }
            
            console.log('Stopping audio playback', isErrorRecovery ? '(error recovery mode)' : '', 
                         skipServerNotification ? '(skipping server notification)' : '');
            
            // Hide any playback status messages if not in error recovery mode
            if (!isErrorRecovery) {
                this.hidePlaybackStatus();
            }
            
            // Stop heartbeat immediately
            this.stopHeartbeat();
            
            // Stop HTML5 audio element
            if (this.audioElement) {
                this.audioElement.pause();
                this.audioElement.src = '';
                this.audioElement.load(); // Reset and clear any buffered data
            }
            
            // Clean up HLS.js if it exists
            if (this.hlsPlayer) {
                this.hlsPlayer.destroy();
                this.hlsPlayer = null;
            }
            
            // Add a cooldown period for error recovery
            if (isErrorRecovery) {
                this.inErrorCooldown = true;
                setTimeout(() => {
                    this.inErrorCooldown = false;
                }, 5000); // 5 second cooldown before allowing playback again
            }
            
            // Store current source for potential auto-restart
            const previousSource = this.playingSource;
            
            // Reset state
            this.isPlaying = false;
            this.playingSource = null;
            
            // Update mediaSession state if available
            if ('mediaSession' in navigator) {
                navigator.mediaSession.playbackState = 'paused';
            }
            
            // Notify server that we've stopped playback - but only if not in recovery mode
            // or if specifically instructed to skip notification
            if (!skipServerNotification && previousSource) {
                const encodedSourceId = encodeURIComponent(previousSource);
                const stopUrl = `${window.location.origin}/api/v1/audio-stream-hls/${encodedSourceId}/stop`;
                
                // Check if network is available before notifying server
                if (navigator.onLine) {
                    fetch(stopUrl, { 
                        method: 'POST',
                        // Add timeout to prevent hanging requests
                        signal: AbortSignal.timeout(5000)
                    })
                    .then(() => console.log('Server notified of playback stop'))
                    .catch(err => {
                        console.error('Failed to notify server of playback stop:', err);
                        
                        // If this was a deliberate user stop (not error recovery),
                        // and we couldn't notify the server, try again once more
                        if (!isErrorRecovery) {
                            console.log('Retrying server notification once');
                            setTimeout(() => {
                                fetch(stopUrl, { method: 'POST' })
                                    .catch(e => console.error('Final attempt to notify server failed:', e));
                            }, 2000);
                        }
                    });
                } else {
                    console.warn('Network offline, skipping server notification');
                }
            } else if (skipServerNotification) {
                console.log('Skipping server notification as requested');
            }
            
            // In error recovery, consider auto-restart after a delay if it was a network issue
            if (isErrorRecovery && navigator.onLine && previousSource) {
                console.log('In error recovery mode, will attempt auto-restart if network is available');
                
                // Only attempt auto-restart for network-related errors if browser shows we're online
                setTimeout(() => {
                    if (navigator.onLine && !this.isPlaying && !this.inErrorCooldown && previousSource) {
                        console.log('Attempting to auto-restart stream after network error');
                        this.showPlaybackStatus('Attempting to reconnect stream...');
                        this.startPlayback(previousSource);
                    }
                }, 8000); // Wait 8 seconds before attempting auto-restart
            }
        },
        
        // Setup media session API for media controls
        setupMediaSession(source) {
            if ('mediaSession' in navigator) {
                const sourceName = source ? this.getSourceDisplayName(source) : '';
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: sourceName ? 'Bird Audio Stream - ' + sourceName : 'Bird Audio Stream',
                    artist: 'BirdNet-Go',
                    album: 'Live Stream',
                    // Optional artwork - use favicon as default
                    artwork: [
                        { src: '/assets/favicon.ico', sizes: '32x32', type: 'image/x-icon' },
                    ]
                });
                
                navigator.mediaSession.setActionHandler('play', () => {
                    if (this.audioElement) {
                        this.audioElement.play();
                    }
                });
                
                navigator.mediaSession.setActionHandler('pause', () => {
                    if (this.audioElement) {
                        this.audioElement.pause();
                    }
                });
                
                // Update playback state
                navigator.mediaSession.playbackState = 'playing';
            }
        },
        
        // Toggle playback for currently selected source
        togglePlayback() {
            if (!this.selectedSource) {
                console.error('No audio source selected');
                return;
            }
            
            if (this.isPlaying) {
                this.stopPlayback();
            } else {
                this.startPlayback(this.selectedSource);
            }
        },
        
        // Toggle playback for a specific source
        toggleSourcePlayback(source) {
            // Check network state first
            if (!navigator.onLine) {
                this.showPlaybackStatus('Network unavailable. Please check your connection.');
                setTimeout(() => this.hidePlaybackStatus(), 3000);
                return;
            }
            
            // If we're in error cooldown, don't allow playback immediately
            if (this.inErrorCooldown) {
                this.showPlaybackStatus('Please wait a moment before trying again...');
                setTimeout(() => this.hidePlaybackStatus(), 3000);
                return;
            }

            // If we're already playing this source, stop it
            if (this.isPlaying && this.playingSource === source) {
                this.stopPlayback();
                return;
            }
            
            // If we're playing a different source, stop it first
            if (this.isPlaying) {
                this.stopPlayback();
            }
            
            // Start playing the new source
            this.startPlayback(source);
        },

        // Initialize component
        init() {
            // Reset error tracking variables
            this.errorCount = 0;
            this.lastErrorTime = 0;
            this.nonFatalErrorCount = 0;
            this.lastNonFatalErrorTime = 0;
            this.inErrorCooldown = false;
            this.playbackStabilizing = false;
            
            // Setup initial connection for audio levels
            this.setupEventSource();
            
            // Remember last playing source for potential network recovery
            let lastPlayingSource = null;
            
            // Network state handlers
            const handleOffline = () => {
                console.warn('Network went offline');
                
                // Store current playback state
                if (this.isPlaying && this.playingSource) {
                    lastPlayingSource = this.playingSource;
                    this.showPlaybackStatus('Network disconnected - playback paused');
                    
                    // Don't send stop notification since network is down anyway
                    this.stopPlayback(true, true);
                }
            };
            
            const handleOnline = () => {
                console.log('Network connection restored');
                
                // If we were playing before, try to resume
                if (lastPlayingSource && !this.isPlaying) {
                    this.showPlaybackStatus('Network reconnected - resuming playback');
                    
                    // Wait a moment for connection to stabilize
                    setTimeout(() => {
                        this.startPlayback(lastPlayingSource);
                        lastPlayingSource = null;
                    }, 2000);
                }
                
                // Also restart EventSource if needed
                if (!this.eventSource) {
                    this.setupEventSource();
                }
            };
            
            // Add network state listeners
            window.addEventListener('offline', handleOffline);
            window.addEventListener('online', handleOnline);
            
            // Add page unload handler to notify server
            const handleUnload = () => {
                // If currently playing, send a disconnect notification
                if (this.isPlaying && this.playingSource) {
                    console.log('Page unloading - notifying server of disconnection');
                    
                    // Use navigator.sendBeacon for more reliable delivery during page unload
                    const heartbeatUrl = `${window.location.origin}/api/v1/audio-stream-hls/heartbeat?disconnect=true`;
                    const heartbeatData = JSON.stringify({
                        source_id: this.playingSource
                    });
                    
                    // Try to use sendBeacon API for more reliable delivery during page unload
                    if (navigator.sendBeacon) {
                        const blob = new Blob([heartbeatData], { type: 'application/json' });
                        navigator.sendBeacon(heartbeatUrl, blob);
                    } else {
                        // Fallback to synchronous XHR if sendBeacon not available
                        try {
                            const xhr = new XMLHttpRequest();
                            xhr.open('POST', heartbeatUrl, false); // false = synchronous
                            xhr.setRequestHeader('Content-Type', 'application/json');
                            xhr.send(heartbeatData);
                        } catch (e) {
                            // Ignore errors during unload
                        }
                    }
                    
                    // Force a stream stop notification as well (belt and suspenders)
                    if (this.playingSource) {
                        const encodedSourceId = encodeURIComponent(this.playingSource);
                        const stopUrl = `${window.location.origin}/api/v1/audio-stream-hls/${encodedSourceId}/stop`;
                        
                        if (navigator.sendBeacon) {
                            navigator.sendBeacon(stopUrl);
                        } else {
                            try {
                                const xhr = new XMLHttpRequest();
                                xhr.open('POST', stopUrl, false);
                                xhr.send();
                            } catch (e) {
                                // Ignore errors during unload
                            }
                        }
                    }
                }
            };
            
            window.addEventListener('beforeunload', handleUnload);
            window.addEventListener('unload', handleUnload);
            
            // Listen for navigation events
            document.addEventListener('htmx:beforeRequest', () => {
                this.isNavigating = true;
                this.cleanupEventSource();
                
                // Stop audio playback if navigating
                if (this.isPlaying) {
                    this.stopPlayback();
                }
            });
            
            document.addEventListener('htmx:afterRequest', () => {
                this.isNavigating = false;
                // Only setup new connection if we're still on a page that needs it
                if (document.body.contains(this.$el)) {
                    this.setupEventSource();
                }
            });

            // Listen for page visibility changes
            const visibilityHandler = () => {
                // Skip all visibility processing during playback stabilization
                if (this.playbackStabilizing) {
                    console.log('Ignoring visibility change during playback stabilization');
                    return;
                }
                
                if (document.hidden) {
                    // When tab goes to background
                    this.cleanupEventSource(); // Close the audio level EventSource when hidden
                    
                    // We don't need to pause audio - it can keep playing in background
                    console.log('Tab in background: continuing audio playback');
                    
                } else if (!this.isNavigating) {
                    // When tab becomes visible again
                    this.setupEventSource();
                    
                    // If we were playing and the player has stopped, restart
                    if (this.playingSource && this.audioElement && 
                        (this.audioElement.paused || this.audioElement.ended) && 
                        !this.inErrorCooldown) { // Don't restart if in error cooldown
                        console.log('Tab visible again: resuming audio playback');
                        // Add a short delay before restarting playback to avoid race conditions
                        setTimeout(() => {
                            this.startPlayback(this.playingSource);
                        }, 500);
                    }
                }
            };
            
            document.addEventListener('visibilitychange', visibilityHandler);
            
            // Clean up on component destroy
            this.$cleanup = () => {
                this.cleanupEventSource();
                document.removeEventListener('visibilitychange', visibilityHandler);
                document.removeEventListener('htmx:beforeRequest', this.cleanupEventSource);
                document.removeEventListener('htmx:afterRequest', this.setupEventSource);
                window.removeEventListener('offline', handleOffline);
                window.removeEventListener('online', handleOnline);
                window.removeEventListener('beforeunload', handleUnload);
                window.removeEventListener('unload', handleUnload);
                
                // Send final disconnect notification
                if (this.isPlaying && this.playingSource) {
                    this.stopHeartbeat(); // This will send the disconnect notification
                }
                
                // Stop heartbeat
                this.stopHeartbeat();
                
                // Clean up audio element
                if (this.audioElement) {
                    this.audioElement.pause();
                    this.audioElement.src = '';
                    this.audioElement.remove();
                    this.audioElement = null;
                }
                
                // Clean up HLS.js if it exists
                if (this.hlsPlayer) {
                    this.hlsPlayer.destroy();
                    this.hlsPlayer = null;
                }
            };
        },
        
        // Get current audio level
        getCurrentLevel() {
            const level = this.selectedSource && this.levels[this.selectedSource] ? 
                this.levels[this.selectedSource].level : 0;
            return level;
        },
        
        // Check if audio is clipping
        isClipping() {
            const clipping = this.selectedSource && this.levels[this.selectedSource] ? 
                this.levels[this.selectedSource].clipping : false;
            return clipping;
        },
        
        // Get smoothed volume for visualization
        getSmoothedVolume() {
            const volume = this.selectedSource ? this.smoothedVolumes[this.selectedSource] || 0 : 0;
            return volume;
        },
        
        // Get display name for a source
        getSourceDisplayName(source) {
            const name = this.levels[source]?.name || source;
            return name;
        }
    }" 
    @click.away="dropdownOpen = false">
    
    <!-- Audio level indicator circle -->
    <button @click="dropdownOpen = !dropdownOpen" 
            class="w-full h-full relative focus:outline-none group" 
            :aria-expanded="dropdownOpen"
            aria-haspopup="true"
            :aria-label="'Audio level for ' + (selectedSource ? getSourceDisplayName(selectedSource) : 'No source')"
            tabindex="0">
        <svg class="w-full h-full" viewBox="0 0 36 36" aria-hidden="true">
            <!-- Background circle path -->
            <path d="M18 2.0845
                        a 15.9155 15.9155 0 0 1 0 31.831
                        a 15.9155 15.9155 0 0 1 0 -31.831" 
                    fill="none" 
                    stroke="#E5E7EB" 
                    stroke-width="3" 
                    stroke-dasharray="100, 100"></path>
            <!-- Foreground circle path -->
            <path d="M18 33.9155
                        a 15.9155 15.9155 0 0 1 0 -31.831
                        a 15.9155 15.9155 0 0 1 0 31.831" 
                    fill="none" 
                    :stroke="isClipping() ? '#EF4444' : '#10B981'" 
                    stroke-width="3" 
                    :stroke-dasharray="getSmoothedVolume() + ', 100'"
                    stroke-linecap="round">
            </path>
        </svg>
        <div class="absolute inset-0 flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z" clip-rule="evenodd"></path>
            </svg>
        </div>
        <!-- Live region to announce volume changes -->
        <div class="sr-only" aria-live="polite" x-text="'Current audio level: ' + Math.round(getSmoothedVolume()) + ' percent' + (isClipping() ? ', clipping detected' : '')"></div>
    </button>

    {{if or (not $.Security.Enabled) $.Security.AccessAllowed}}
    <!-- Tooltip for selected source -->
    <div x-show="selectedSource && !dropdownOpen"
         x-transition:enter="transition ease-out duration-100"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100"
         x-transition:leave="transition ease-in duration-75"
         x-transition:leave-start="opacity-100"
         x-transition:leave-end="opacity-0"
         class="invisible group-hover:visible absolute left-1/2 transform -translate-x-1/2 -translate-y-full mt-2 px-2 py-1 bg-gray-900 text-gray-50 text-sm rounded whitespace-nowrap z-50"
         style="top: -5px;"
         aria-hidden="true">
        <span x-text="selectedSource ? getSourceDisplayName(selectedSource) : 'No source selected'"></span>
    </div>
    
    <!-- Dropdown menu, shown only for authenticated users -->
    <div x-show="dropdownOpen"
         role="dialog"
         aria-modal="true"
         :aria-label="'Audio Source Selection'"
         class="absolute p-1 right-0 mt-2 w-auto min-w-[12rem] max-w-[90vw] overflow-hidden rounded-md shadow-lg bg-base-100 ring-1 ring-black ring-opacity-5 z-50"
         x-transition:enter="transition ease-out duration-100"
         x-transition:enter-start="opacity-0 scale-95"
         x-transition:enter-end="opacity-100 scale-100"
         x-transition:leave="transition ease-in duration-75"
         x-transition:leave-start="opacity-100 scale-100"
         x-transition:leave-end="opacity-0 scale-95"
         @keydown.escape.window="dropdownOpen = false"
         @keydown.tab="$event.shiftKey || $el.querySelector('.last-focusable').focus()"
         @keydown.shift.tab="$el.querySelector('.first-focusable').focus()">
        <div class="py-1" role="menu" aria-orientation="vertical">
            <template x-if="Object.keys(levels).length === 0">
                <div class="px-4 py-2 text-sm text-base-content/60" role="menuitem">No audio sources available</div>
            </template>
            <template x-for="(data, source) in levels" :key="source">
                <div class="flex flex-row items-center w-full p-2 text-sm hover:bg-base-200 rounded-md"
                     :class="{
                         'bg-base-200': selectedSource === source,
                         'text-base-content/50': isInactive(source),
                         'text-base-content': !isInactive(source)
                     }"
                     role="menuitem"
                     :id="'source-item-' + source">
                    <!-- Source name area (clickable to select) -->
                    <button @click="selectedSource = source; dropdownOpen = false" 
                            class="flex-1 text-left flex items-center justify-between"
                            role="menuitemradio"
                            :aria-checked="selectedSource === source"
                            :tabindex="source === Object.keys(levels)[0] ? 0 : -1"
                            :class="{ 'first-focusable': source === Object.keys(levels)[0] }"
                            @keydown.right="$event.target.nextElementSibling?.focus()">
                        <span class="flex-1 whitespace-nowrap" x-text="getSourceDisplayName(source)"></span>
                        <span x-show="isInactive(source)" class="text-xs text-base-content/50 shrink-0 ml-2" aria-hidden="true">(silent)</span>
                        <!-- Accessible label that includes silence status -->
                        <span class="sr-only" x-text="isInactive(source) ? getSourceDisplayName(source) + ' (currently silent)' : getSourceDisplayName(source)"></span>
                    </button>
                    
                    <!-- Play/Stop controls directly in same row -->
                    <button 
                            @click="toggleSourcePlayback(source); dropdownOpen = false" 
                            class="btn btn-xs btn-circle btn-ghost ml-2"
                            :class="playingSource === source ? 'text-error' : 'text-success'"
                            :aria-label="playingSource === source ? 'Stop audio playback' : 'Start audio playback'"
                            :tabindex="0"
                            @keydown.left="$event.target.previousElementSibling?.focus()">
                        <template x-if="playingSource !== source">
                            <!-- Play icon (>) -->
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                            </svg>
                        </template>
                        <template x-if="playingSource === source">
                            <!-- Stop icon (#) -->
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clip-rule="evenodd" />
                            </svg>
                        </template>
                    </button>
                </div>
            </template>
        </div>
    </div>
    
    {{end}}

    <!-- Live region for audio playback status -->
    <div aria-live="polite" class="sr-only">
        <span x-show="isPlaying" x-text="'Now playing audio from ' + (selectedSource ? getSourceDisplayName(selectedSource) : 'unknown source')"></span>
        <span x-show="!isPlaying && selectedSource" x-text="'Audio playback stopped'"></span>
    </div>

</div>

<!-- Add this script to the bottom for better keyboard navigation -->
<script>
document.addEventListener('alpine:init', () => {
    // A11y: Enhance keyboard interaction for dropdown
    window.addEventListener('keydown', (e) => {
        // Close dropdown on escape
        if (e.key === 'Escape' && Alpine.$data(document.querySelector('[x-data*="dropdownOpen"]')).dropdownOpen) {
            Alpine.$data(document.querySelector('[x-data*="dropdownOpen"]')).dropdownOpen = false;
        }
    });
});
</script>
{{end}} 